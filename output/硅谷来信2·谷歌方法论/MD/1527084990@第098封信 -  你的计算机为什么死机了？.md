# 第098封信 | 你的计算机为什么死机了？

今天我们讲讲计算机软件和操作系统的一些原理，你不用被这两个名词给吓着，因为今天的内容很容易懂。在讲今天的内容之前，先问你一个问题： **你到银行的窗口排队等候服务，到底是应该先来先服务，还是后来先服务，还是采用什么别的原则为客户服务？**

我估计大部分人都会说，当然是先来先服务了，因为这样公平。这个说法没有错，确实对每一个请求服务的人来讲都很公平，但是这里面有三个问题：

 **1. 首先，如果服务第一个人太花时间，后面的人等待时间都特别长，总体花的时间就特别多，这样似乎缺失了整体的公平性。** 这种情况你其实在生活中经常遇到，在排队时如果前面某个顾客遇到点什么状况，整个队就不动了。这时后面的人其实都在想，能不能把我们的业务先办了，我的业务非常快，这样队列中就不会拥堵那么多的人。这种情况在计算机处理事物时也会遇到。

2. 其次，这种先来先服务的做法实际上有一个假设前提，就是每一个站在队列中的人是可以自己往前走一步的。 **如果排队的不是具有动力的人，而是一个个自己不会动的箱子，问题就麻烦了。** 当第一个箱子的业务办完了，就需要有人（或者其他什么动力）将第二个箱子放到第一个位置，第三个放到第二个的位置，以此类推。每处理一个业务，就要所有的箱子大搬家。对于计算机来讲，如果把计算机的宝贵资源都用来搬那些排队的箱子，而不是处理业务，效率就一定低。

当然，聪明的读者朋友会想，能否箱子别动，办业务的人走动，这其实是早期生产线的做法。这种方法确实可以解决上述问题，但是带来了下面这个新问题。

 **3. 如果箱子不动，人走动，我们可以认为处理完业务后，箱子就消失了，但是留下来的空位子也就浪费了。** 在计算机里，资源是有限的，要不断回收管理，这个管理如何做到高效率也是个问题。

由此可见，我们很多时候想的很简单的事情，在实际操作时会遇到想不到的困难。为了解决第二、第三个问题，计算机科学家们干脆设计了一种先进后出，或者先来后服务的的数据结构，叫做 **堆栈** 。

比如张三、李四、王五先后进到一个房间，出门的时候，王五先出去，李四再走，张三最后出去。这种安排看似不合理，却解决了前面两个问题，因为一个东西放进堆栈后在处理完之前并不需要移动，其次处理完的任务自动出栈，新进来的任务直接占有腾出来的位置，不存在空间被浪费的问题。

先进后出的策略在现实生活中是否有可以对应的真实场景？不仅有，其实还不少。比如很多火车站都在铁路的一个尽头，火车到那里要调头出发，这就是先进后出。大家坐电梯，坐飞机，进电影院也是如此。

在计算机中，堆栈这种先进后出的数据结构和处理任务的策略也被称为FILO（First In Last Out）或者FILS（First In Last Serve）。你可以想象一堆东西，放的时候先放底下的，拿的时候先拿上面的。和它对应的先进先出的数据结构被称为 **队列** （Queue），你可以想象出我们排队的场景，先来先服务，它也被称为FIFO（First In First Out）或者FIFS（First In First Serve）。

先进后出的策略在金融中也有应用，在世界大部分国家，交易股票挣了钱是要交税的，因此如果一个人分几次买了一些股票，比如买了五次，每次买了一百股，等到卖的时候，先卖哪一部分股票呢？通常的策略是先进后出，后进先出。也就是说先卖掉最后买的，因为通常股票是上涨的，最后买的价格都比较高，卖掉这些成本高的，交易的利润较低，缴税较少。

此外，大公司在管理上裁员时有时会采用把入职不久的新人先裁掉，因为他们参与业务程度还不深，裁掉他们公司的损失最小。在职场上有些喜欢跳槽的人也因此陷入总是被裁员的怪圈，因为他们总是公司里资历最浅的员工。

无论用堆栈还是队列，其实都还没有解决上面第一个问题，也就是如果计算机遇到了一个需要特别长时间才能完成的任务怎么办。这就涉及到操作系统里面一个资源调度的问题了。通常，计算机在同时需要执行几个程序时，会根据下面几种策略来决定先运行哪一个，后运行哪一个，这些策略大致如下：

 **第一种，先来的先服务。**

 **第二种，执行起来最省时间的先服务。**

 **第三种，最少占用资源的先服务。**

 **第四种，释放资源最多的先服务。**

 **第五种，优先级高的先服务。**

当然上述每一种都有它的道理，也有它的缺点。如果我们采用第二种，总是执行那些最省时间的事情，那么一个很早就来排队，但是要很长时间才能完成的程序，就永远没有机会被执行了。为了解决这些矛盾，计算机操作系统的设计者，通常会把上述几种方案混合使用。比如同时设定，等待时间越长的任务优先级越高，任务越小优先级越高，这样如果一个任务虽然很大，但是等待时间已经很长了，还会让它有机会运行。

一种计算机如果运行各种程序的次序安排不合理，使用者就会感觉计算机特别慢。更糟糕的是，计算机里面的很多程序并非彼此独立的，而是有一些依赖性，比如程序C的运行必须等到程序B的完成，程序B的运行必须等待程序A的完成。 *如果调度不合理，会有一大堆程序堆在队列中，在用户看来计算机似乎不动了，感觉上就像死机了一样。* 这是我们见到的死机的第一个原因。

更糟糕的情况是，如果程序A依赖于程序B，程序B依赖于程序C，程序C又反过来依赖于程序A，这就形成死循环了，计算机就真的“死翘翘”了，除了重启没有更好的解决方法。

再有第三种情况，计算机软件有一些Bug， *各种程序进入队列或者堆栈，在离开时次序搞乱了，也会出现死机。*

总之， **计算机本身并不具有智能的特性，它表现的好坏，完全取决于管理和调度资源的操作系统。**

很多时候，我们买计算机的时候，过分注重硬件上的指标，而忽视操作系统的好坏。比如苹果机和其他运行微软操作系统的PC机相比，其实使用的处理器都是英特尔的，差不太多，配置也差不多。但是运行一段时间以后，特别是装的软件多了以后，后者似乎运行起来比前者要慢。这倒不是我个人的体会，而是共识，其原因主要在于操作系统。

你如果买一台PC机，通常三年后就慢得没法使用了，但是一台苹果机5年后还勉强能用。这里我倒没有贬低微软的意思，它的操作系统有很多优点，但是在管理资源方面，实在做得不够好。也正是因为这种原因，微软在手机操作系统上的市场份额几乎为零。

计算机在资源管理上，很多原则和我们日常生活和工作的原则相似，比如什么时候才有先进先出，先来先服务，或是反过来。但是在两个方面，它的思维方式和我们人完全不同。

 **其一，它并不追求公平、平等这样道德层面的目标，而是追求运行的整体效率。** 比如在资源紧张时，它通常不采用先来先服务这种公平的方式。很多时候，效率和公平性是矛盾的，计算机的好处在于，它不需要为公平发愁。而在我们人的社会里，却不能这样想。

其二，由于它的资源调度和使用策略是事先规划好的，尽管计算机科学家事先总是要把各种情况考虑完整，但是总是有一些事先无法预知的情况无法处理，以至于出现拥堵和死锁，而计算机本身是无法解决这些问题的，于是就 **出现死机，一切必须重新开始。** 但是人遇到这种情况则不同，人可以不按照事先设定的规则行事，因此可以解开死局。

大家可能都有这样一种经验，在十字路口红绿灯坏了，如果没有警察来疏导，很快四面而来的车辆会死锁在那里。这时来了一个警察进行疏导，强制一些车辆停下来，可能还会让一些车辆逆行，但是很快就可以把拥堵的路口清空，恢复车道的正常状态。

此外，我们今天还应该体会一点，很多看似简单的、理所当然的事情，后面其实可能很复杂。而为了解决这些复杂的问题，人们又抽象出一些简单的概念，比如堆栈和队列，然后一次性地解决许多相似的复杂问题。 *科学家所必需具备的一种特殊能力就是要能够抽象出这些概念。*

有了今天对堆栈这种数据结构的了解，明天我们就能够介绍计算机科学中最精髓的方法——递归了。

![https://piccdn3.umiwi.com/img/201805/14/201805141526163859322434.png](https://piccdn3.umiwi.com/img/201805/14/201805141526163859322434.png)

## 划重点

1.计算机本身并不具有智能的特性，它表现的好坏，完全取决于管理和调度资源的操作系统。

2.科学家所必需具备的一种特殊能力就是要能够抽象出这些概念。

![https://piccdn3.umiwi.com/img/201805/14/201805141526308654127169.jpg](https://piccdn3.umiwi.com/img/201805/14/201805141526308654127169.jpg)

---
